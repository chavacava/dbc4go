//go:generate dbc4go -i $GOFILE -o $GOFILE
package generator

import (
	"bytes"
	"fmt"
	"go/ast"
	"go/format"
	"go/parser"
	"go/token"
	"io"
	"log"
	"strconv"
	"strings"

	"github.com/chavacava/dbc4go/internal/contract"
	cparser "github.com/chavacava/dbc4go/internal/contract/parser"
	"github.com/dave/dst"
	"github.com/dave/dst/decorator"
	"github.com/pkg/errors"
	"golang.org/x/tools/go/ast/astutil"
)

const generatedHeader = "// Code generated by dbc4go, DO NOT EDIT.\n"

//@ensures len(str)<=len(r)
func escapeDoubleQuotes(str string) (r string) {
	return strings.Replace(str, "\"", "\\\"", -1)
}

// GenerateCode produces the contract enforcing code for the given source file
func GenerateCode(input io.Reader, output io.Writer) error {
	buf, err := analyzeCode(input)
	if err != nil {
		return errors.Wrap(err, "unable to analyze input source code")
	}

	_, err = fmt.Fprintf(output, "%s", buf.Bytes())
	if err != nil {
		return errors.Wrap(err, "unable to write output source code")
	}

	return nil
}

//@ensures r.Len() == 0 ==> err != nil
//TODO(chavacava) how to ensure that r is valid Go code?
func analyzeCode(src io.Reader) (r bytes.Buffer, err error) {
	fset := token.NewFileSet()
	astFile, err := parser.ParseFile(fset, "", src, parser.ParseComments)
	if err != nil {
		return bytes.Buffer{}, fmt.Errorf("unable to parse code: %v", err)
	}

	dec := decorator.NewDecorator(fset)
	dstFile, err := dec.DecorateFile(astFile)
	if err != nil {
		return bytes.Buffer{}, fmt.Errorf("unable to decorate AST: %v", err)
	}

	fa := fileAnalyzer{decorator: dec, imports: importsContainer{}}
	// walk the AST with the analyzer to find contracts and generate their contracts
	ast.Walk(fa, astFile)

	fset, astFile, err = decorator.RestoreFile(dstFile)
	if err != nil {
		return bytes.Buffer{}, fmt.Errorf("unable to generate new code: %v", err)
	}

	// add imports required by contracts
	for k := range fa.imports {
		astutil.AddImport(fset, astFile, k)
	}

	var buf bytes.Buffer
	if err := format.Node(&buf, fset, astFile); err != nil {
		return bytes.Buffer{}, fmt.Errorf("unable to format the new code: %v", err)
	}

	// Add standard header for generated files
	code := buf.String()
	buf.Reset()
	buf.WriteString(generatedHeader)
	buf.WriteString(code)

	finalCode := strings.ReplaceAll(buf.String(), commentPrefix, "")
	buf.Reset()
	buf.WriteString(finalCode)

	// re-parse file to check for errors in generated code
	resultFile, err := parser.ParseFile(fset, "", &buf, parser.ParseComments)
	if err != nil {
		return bytes.Buffer{}, fmt.Errorf("found error in generated code, please check contracts: %v", err)
	}

	// format generated code
	buf.Reset()
	if err := format.Node(&buf, fset, resultFile); err != nil {
		return bytes.Buffer{}, fmt.Errorf("unable to format the generated code: %v", err)
	}

	return buf, nil
}

type importsContainer map[string]struct{}

type fileAnalyzer struct {
	decorator *decorator.Decorator
	imports   importsContainer
}

func (fa fileAnalyzer) Visit(node ast.Node) ast.Visitor {
	switch n := node.(type) {
	case *ast.FuncDecl:
		fa.rewriteFuncDecl(n)
		return nil //skip visiting function body
	}

	return fa
}

// positionAsString returns a string representation of the given token position
//@requires fa.decorator.Fset != nil
func (fa fileAnalyzer) positionAsString(pos token.Pos) string {
	position := fa.decorator.Fset.Position(pos)

	return position.Filename + ":" + strconv.Itoa(position.Line) + ":" + strconv.Itoa(position.Column)
}

// rewriteFuncDecl is in charge of generating contract-enforcing code for functions
//@requires fd != nil
func (fa *fileAnalyzer) rewriteFuncDecl(fd *ast.FuncDecl) {
	if fd.Doc == nil {
		return // nothing to do, the function does not have a comment
	}

	cp := cparser.NewParser()
	contract := contract.NewFuncContract(fd)
	comments := fd.Doc.List
	for _, commentLine := range comments {
		err := cp.Parse(&contract, commentLine.Text)
		if err != nil {
			log.Printf("%s: Warning: %s", fa.positionAsString(commentLine.Pos()), err.Error())
			continue
		}
	}

	contractStmts, errs := fa.generateCode(&contract)
	for _, err := range errs {
		log.Printf("Warning: %v", err)
	}

	dstFuncDecl := fa.decorator.Dst.Nodes[fd].(*dst.FuncDecl)
	dstFuncDecl.Body.Decorations().Start.Append(contractStmts...)

	return
}

// generateCode yields the list of GO statements that enforce the given contract
// It also yields the list of errors that occurred while the generation
//@requires c != nil
// All ensures are grouped in a single defer statement and there is an if statement for each require
//@ensures len(c.Ensures()) > 0 ==> len(c.Requires())+1 == len(stmts)+len(errs)
//@ensures len(c.Ensures()) == 0 ==> len(c.Requires()) == len(stmts)+len(errs)
func (fa fileAnalyzer) generateCode(c *contract.FuncContract) (stmts []string, errs []error) {
	result := []string{}
	errs = []error{}
	for _, r := range c.Requires() {
		stmt, err := fa.generateRequiresCode(r)
		if err != nil {
			errs = append(errs, errors.Wrapf(err, "unable to generate code for the clause '%s'", r))
			continue
		}

		result = append(result, stmt)
	}

	if len(c.Ensures()) > 0 {
		stmt := fa.generateEnsuresCode(c.Ensures(), c.Target())
		result = append(result, stmt)
	}

	// merge new imports into imports list
	for k, v := range c.Imports() {
		fa.imports[k] = v
	}

	return result, errs
}

const commentPrefix = "//dbc4go "

//@ensures  r == "" ==> e != nil
func (fileAnalyzer) generateRequiresCode(req contract.Requires) (r string, e error) {
	const templateRequire = commentPrefix + `if !(%cond%) { panic("precondition %contract% not satisfied") }`
	exp := req.ExpandedExpression()

	r = strings.Replace(templateRequire, "%cond%", exp, 1)
	r = strings.Replace(r, "%contract%", escapeDoubleQuotes(req.String()), 1)

	return r, nil
}

//@requires fd != nil
//@requires len(clauses) > 0
//@ensures r != ""
func (fa fileAnalyzer) generateEnsuresCode(clauses []contract.Ensures, fd *ast.FuncDecl) (r string) {
	const templateEnsure = commentPrefix + `if !(%cond%) { panic("postcondition %contract% not satisfied") }`

	ensuresCode := make([]string, len(clauses))
	for _, clause := range clauses {
		exp := clause.ExpandedExpression()
		ensure := strings.Replace(templateEnsure, "%cond%", exp, 1)
		ensure = strings.Replace(ensure, "%contract%", escapeDoubleQuotes(clause.String()), 1)
		ensuresCode = append(ensuresCode, ensure)
	}

	funcParams := []string{}
	funcArgs := []string{}

	const oldPrefix = "old_"
	if fd.Type.Params != nil {
		for _, param := range fd.Type.Params.List {
			paramID := param.Names[0].String()

			funcParams = append(funcParams, fmt.Sprintf("%s %s", oldPrefix+paramID, fa.typeAsString(param.Type)))
			funcArgs = append(funcArgs, paramID)
		}
	}

	hasReceiver := fd.Recv != nil && len(fd.Recv.List) > 0 && len(fd.Recv.List[0].Names) > 0 && fd.Recv.List[0].Names[0].String() != "_"
	if hasReceiver {
		receiverID := fd.Recv.List[0].Names[0].String()
		funcParams = append(funcParams, fmt.Sprintf("%s %s", oldPrefix+receiverID, fa.typeAsString(fd.Recv.List[0].Type)))
		funcArgs = append(funcArgs, receiverID)
	}

	const templateDeferredFunction = commentPrefix + `defer func(%params%){%checks%}(%args%)`

	r = strings.Replace(templateDeferredFunction, "%params%", strings.Join(funcParams, ","), 1)
	r = strings.Replace(r, "%checks%", strings.Join(ensuresCode, "\n"), 1)
	r = strings.Replace(r, "%args%", strings.Join(funcArgs, ","), 1)

	return r
}

//@requires n != nil
//@ensures r != ""
func (fa fileAnalyzer) typeAsString(n ast.Node) (r string) {
	switch n := n.(type) {
	case *ast.ArrayType:
		return "[]" + fa.typeAsString(n.Elt)
	case *ast.Ellipsis:
		return "..." + fa.typeAsString(n.Elt)
	case *ast.StarExpr:
		return "*" + fa.typeAsString(n.X)
	case *ast.SelectorExpr:
		return fmt.Sprintf("%v", n.X) + "." + fa.typeAsString(n.Sel)
	default:
		return fmt.Sprintf("%v", n)
	}
}
