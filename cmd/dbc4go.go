//go:generate dbc4go -i $GOFILE -o $GOFILE
package main

import (
	"bytes"
	"flag"
	"fmt"
	"go/ast"
	"go/format"
	"go/parser"
	"go/token"
	"io/ioutil"
	"log"
	"os"
	"strconv"

	"github.com/pkg/errors"

	"github.com/chavacava/dbc4go/internal/contract"
	"github.com/chavacava/dbc4go/internal/contract/generator"
	cparser "github.com/chavacava/dbc4go/internal/contract/parser"

	"github.com/fatih/astrewrite"
)

const generatedHeader = "// Code generated by dbc4go, DO NOT EDIT.\n"

func main() {
	inputFilename := flag.String("i", "", "input source file")
	outputFilename := flag.String("o", "", "output file (defaults to stdout")
	flag.Parse()

	if *inputFilename == "" {
		log.Fatal("Undefined input file, please set the flag -i")
	}

	err := generateCode(*inputFilename, *outputFilename)
	if err != nil {
		log.Fatalf("Unable to generate code: %v", err)
	}
}

func generateCode(inputFilename, outputFilename string) error {
	inputSourceCode, err := ioutil.ReadFile(inputFilename)
	if err != nil {
		return errors.Wrap(err, "unable to open input file")
	}
	buf, err := analyzeCode(inputSourceCode, inputFilename)
	if err != nil {
		return errors.Wrap(err, "unable to analyze input source code")
	}

	output := os.Stdout

	if outputFilename != "" {
		var err error
		output, err = os.Create(outputFilename)
		if err != nil {
			return errors.Wrapf(err, "unable to create output file '%s'", outputFilename)
		}
		defer output.Close()

		log.Printf("Generating file '%s'", outputFilename)
	}

	_, err = fmt.Fprintf(output, "%s", buf.Bytes())
	if err != nil {
		return errors.Wrap(err, "unable to write output source code")
	}

	return nil
}

func analyzeCode(src []byte, fileName string) (bytes.Buffer, error) {
	fset := token.NewFileSet()
	file, err := parser.ParseFile(fset, fileName, src, parser.ParseComments)
	if err != nil {
		return bytes.Buffer{}, fmt.Errorf("could not parse code: %v", err)
	}

	fr := fileRewriter{fset: fset}
	newFile := astrewrite.Walk(file, fr.rewrite)

	var buf bytes.Buffer
	if err := format.Node(&buf, fset, newFile); err != nil {
		return bytes.Buffer{}, fmt.Errorf("could not format the new code: %v", err)
	}

	if fr.modified {
		// Add standard header for generated files
		code := buf.String()
		buf.Reset()
		buf.WriteString(generatedHeader)
		buf.WriteString(code)
	}

	return buf, nil
}

type fileRewriter struct {
	fset     *token.FileSet
	modified bool
}

// rewrite rewrites an AST node
// this function is to be used with astrewrite.Walk
func (fr *fileRewriter) rewrite(node ast.Node) (ast.Node, bool) {
	switch n := node.(type) {
	case *ast.FuncDecl:
		fd := fr.rewriteFuncDecl(n)
		return fd, true
	}

	return node, true
}

// positionAsString returns a string representation of the given token position
//@requires fr.fset != nil
func (fr *fileRewriter) positionAsString(pos token.Pos) string {
	position := fr.fset.Position(pos)
	return position.Filename + ":" + strconv.Itoa(position.Line) + ":" + strconv.Itoa(position.Column)
}

// rewriteFuncDecl is in charge of generating contract-enforcing code for functions
//@requires fd != nil
func (fr *fileRewriter) rewriteFuncDecl(fd *ast.FuncDecl) *ast.FuncDecl {
	if fd.Doc == nil {
		return fd // nothing to do, the function does not have a comment
	}

	cp := cparser.NewParser()
	contract := contract.NewFuncContract(fd)
	comments := fd.Doc.List
	for _, commentLine := range comments {
		err := cp.Parse(&contract, commentLine.Text)
		if err != nil {
			log.Printf("%s: Warning: %s", fr.positionAsString(commentLine.Pos()), err.Error())
			continue
		}
	}

	contractStmts, errs := generator.GenerateCode(&contract)
	for _, err := range errs {
		log.Printf("Warning: %v", err)
	}

	fd.Body.List = append(contractStmts, fd.Body.List...)

	fr.modified = fr.modified || len(contractStmts) > 0

	return fd
}
